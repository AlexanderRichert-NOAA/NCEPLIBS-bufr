!> @file
!> @brief Read or write a BUFR message.
!>
!> @authors J. Woollen, J. Ator @date 1994-01-06

!> Read the next BUFR message from logical unit abs(lunxx) into internal arrays.
!>
!> Logical unit abs(lunxx) should have already been opened for
!> input operations via a previous call to subroutine openbf().
!>
!> Whenever this subroutine returns with iret = 0, this indicates
!> that a new BUFR message of type subset and date-time jdate was
!> successfully read into internal arrays within the NCEPLIBS-bufr
!> software, and from where it can then be easily manipulated or further
!> parsed via a call to one of the
!> [subset-reading subroutines](@ref hierarchy). Otherwise,
!> if the subroutine returns with iret = -1, then this indicates that
!> there are no more BUFR messages (i.e. end-of-file) within the file
!> connected to logical unit abs(lunxx).
!>
!> @remarks
!> - Any DX BUFR table messages encountered within abs(lunxx) will be
!> automatically processed and stored internally, so a successful return
!> from this subroutine will always result in a BUFR message containing
!> actual data values within the internal arrays.
!> - In prior versions of the NCEPLIBS-bufr software, an input value of
!> lunxx < 0 was an indicator to the subroutine to treat any read error
!> from abs(lunxx) the same as an end-of-file condition. This option is
!> no longer supported, but the capability to call this subroutine with
!> lunxx < 0 is itself still supported for backwards-compatibility with
!> certain legacy application programs.
!>
!> @param lunxx - Absolute value is Fortran logical unit number for BUFR file
!> @param subset - Table A mnemonic for type of BUFR message that was read
!> (see [DX BUFR Tables](@ref dfbftab) for further information about Table A mnemonics)
!> @param jdate - Date-time stored within Section 1 of BUFR message that was read, in format of either
!> YYMMDDHH or YYYYMMDDHH, depending on the most recent call to subroutine datelen()
!> @param iret - return code
!> - 0 = new BUFR message was successfully read into internal arrays
!> - -1 = there are no more BUFR messages in the file connected to logical unit abs(lunxx)
!>
!> @authors J. Woollen, J. Ator @date 1994-01-06
recursive subroutine readmg(lunxx,subset,jdate,iret)

  use bufrlib

  use modv_vars, only: im8b

  use moda_msgcwd
  use moda_sc3bfr
  use moda_bitbuf

  implicit none

  integer, intent(in) :: lunxx
  integer, intent(out) :: jdate, iret
  integer iprt, my_lunxx, lunit, lun, il, im, ier, idxmsg

  character*8, intent(out) :: subset
  character*128 errstr

  common /quiet/ iprt

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunxx,my_lunxx,1)
    call readmg(my_lunxx,subset,jdate,iret)
    call x48(jdate,jdate,1)
    call x48(iret,iret,1)

    im8b=.true.
    return
  endif

  iret = 0
  lunit = abs(lunxx)

  ! Check the file status

  call status(lunit,lun,il,im)
  if(il.eq.0) call bort('BUFRLIB: READMG - INPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR INPUT')
  if(il.gt.0) call bort('BUFRLIB: READMG - INPUT BUFR FILE IS OPEN FOR OUTPUT, IT MUST BE OPEN FOR INPUT')
  call wtstat(lunit,lun,il,1)

  ! Read a message into the internal message buffer

  do while (.true.)
    call rdmsgw(lunit,mbay(1,lun),ier)
    if(ier.eq.-1) then
      ! EOF on attempted read
      call wtstat(lunit,lun,il,0)
      inode(lun) = 0
      idate(lun) = 0
      subset = ' '
      jdate = 0
      iret = -1
      return
    endif

    ! Parse the message section contents
    if(isc3(lun).ne.0) call reads3(lun)
    call cktaba(lun,subset,jdate,iret)

    ! Check for a dictionary message
    if(idxmsg(mbay(1,lun)).ne.1) return

    ! This is an internal dictionary message that was generated by the NCEPLIBS-bufr software.
    if(isc3(lun).ne.0) return

    ! Section 3 decoding isn't being used, so backspace the file pointer and then use subroutine rdbfdx() to read in
    ! all such dictionary messages (they should be stored consecutively!) and reset the internal tables.
    call backbufr_c(lun)
    call rdbfdx(lunit,lun)
    if(iprt.ge.1) then
      call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
      errstr = 'BUFRLIB: READMG - INTERNAL DICTIONARY MESSAGE READ; ACCOUNT FOR IT THEN READ IN NEXT MESSAGE WITHOUT RETURNING'
      call errwrt(errstr)
      call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
      call errwrt(' ')
    endif
  enddo

end subroutine readmg

!> Call subroutine readmg() and pass back its return code as the function value.
!>
!> The use of this function allows the return code from readmg() to be
!> used as the target variable within an iterative program loop.
!>
!> @param lunit - Fortran logical unit number for BUFR file
!> @param subset - Table A mnemonic for type of BUFR message that was read
!> (see [DX BUFR Tables](@ref dfbftab) for further information about Table A mnemonics)
!> @param idate - Date-time stored within Section 1 of BUFR message that was read,
!> in format of either YYMMDDHH or YYYYMMDDHH, depending on the most recent call to subroutine datelen()
!> @returns ireadmg - Return code:
!> - 0 = new BUFR message was successfully read into internal arrays
!> - -1 = there are no more BUFR messages in the file connected to logical unit lunit
!>
!> @author J. Woollen @date 1994-01-06
recursive integer function ireadmg(lunit,subset,idate) result(iret)

  use modv_vars, only: im8b

  implicit none

  integer, intent(in) :: lunit
  integer, intent(out) :: idate
  integer my_lunit

  character*8, intent(out) :: subset

  ! Check for I8 integers

  if(im8b) then
     im8b=.false.

     call x84(lunit,my_lunit,1)
     iret=ireadmg(my_lunit,subset,idate)
     call x48(idate,idate,1)

     im8b=.true.
     return
  endif

  call readmg(lunit,subset,idate,iret)

  return
end function ireadmg

!> Read a BUFR message from a memory array.
!>
!> This subroutine is similar to subroutine readmg(), except that it
!> reads a BUFR message from an array passed as input, whereas
!> readmg() reads a BUFR message from a file on the local system.
!>
!> This subroutine can be used in any context in which readmg()
!> might otherwise be used, and from that point on, the application
!> program can proceed with a call to one of the
!> [subset-reading subroutines](@ref hierarchy) (and then,
!> subsequently, to any of the
!> [values-reading subroutines](@ref hierarchy)).
!>
!> When using this subroutine, it's necessary for the
!> application program to have previously called subroutine openbf() in
!> order to associate a DX BUFR tables file with the message that is
!> being input via mesg; it's also necessary to pass in the
!> relevant lunit value as a call argument, even though in this case
!> the subroutine will not actually try to read from the associated
!> Fortran logical unit.
!>
!> If mesg contains a DX BUFR table message, the subroutine will
!> store the contents internally and use them to process any
!> future BUFR messages associated with lunit. In this case, the
!> subroutine will return with iret = 11, and any number of
!> DX BUFR table messages passed in via consecutive calls to this
!> subroutine will accumulate internally and be treated as a single DX
!> BUFR table, up until a call is made where mesg no longer contains a
!> DX BUFR table message.
!>
!> @param mesg - BUFR message
!> @param lunit - Fortran logical unit number for BUFR file
!> @param subset - Table A mnemonic for type of BUFR message that was read
!> (see [DX BUFR Tables](@ref dfbftab) or further information about Table A mnemonics)
!> @param jdate - Date-time stored within Section 1 of BUFR message that was read,
!> in format of either YYMMDDHH or YYYYMMDDHH, depending on the most recent call to datelen()
!> @param iret - return code:
!> - 0 mesg was successfully read
!> - 11 mesg contained a DX BUFR table message
!> - -1 mesg contained an unrecognized Table A message type
!>
!> @authors J. Woollen J. Ator @date 1995-06-28
recursive subroutine readerme(mesg,lunit,subset,jdate,iret)

  use modv_vars, only: mxmsgl, im8b, nbytw

  use moda_sc3bfr
  use moda_idrdm
  use moda_bitbuf

  implicit none

  integer, intent(in) :: lunit, mesg(*)
  integer, intent(out) :: jdate, iret
  integer iprt, my_lunit, iec0(2), lun, il, im, ii, lnmsg, lmsg, idxmsg, iupbs3

  character*8, intent(out) :: subset
  character*8 sec0
  character*128 errstr, bort_str

  logical endtbl

  equivalence (sec0,iec0)

  common /quiet/ iprt

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunit,my_lunit,1)
    call readerme(mesg,my_lunit,subset,jdate,iret)
    call x48(jdate,jdate,1)
    call x48(iret,iret,1)

    im8b=.true.
    return
  endif

  iret = 0

  ! Check the file status

  call status(lunit,lun,il,im)
  if(il.eq.0) call bort('BUFRLIB: READERME - INPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR INPUT')
  if(il.gt.0) call bort('BUFRLIB: READERME - INPUT BUFR FILE IS OPEN FOR OUTPUT, IT MUST BE OPEN FOR INPUT')
  call wtstat(lunit,lun,il, 1)

  ! Copy the input message into the internal message buffer

  iec0(1) = mesg(1)
  iec0(2) = mesg(2)
  lnmsg = lmsg(sec0)
  if(lnmsg*nbytw.gt.mxmsgl) then
    write(bort_str,'("BUFRLIB: READERME - INPUT BUFR MESSAGE LENGTH",1X,I6," BYTES) IS LARGER THAN '// &
      'LIMIT OF ",I6," BYTES")') lnmsg*nbytw, mxmsgl
    call bort(bort_str)
  endif
  do ii=1,lnmsg
    mbay(ii,lun) = mesg(ii)
  enddo

  ! Confirm that the first 4 bytes of SEC0 contain 'BUFR'.

  if(sec0(1:4).ne.'BUFR') &
    call bort('BUFRLIB: READERME - FIRST 4 BYTES READ FROM RECORD NOT "BUFR", DOES NOT CONTAIN BUFR DATA')

  ! Parse the message section contents

  if(isc3(lun).ne.0) call reads3(lun)
  call cktaba(lun,subset,jdate,iret)
  if(isc3(lun).ne.0) return

  ! Check for a DX dictionary message

  ! A new DX dictionary table can be passed in as a consecutive set of DX dictionary messages.  Each message should be passed
  ! in one at a time, via input argument mesg during consecutive calls to this subroutine, and all such messages will be
  ! treated as a single dictionary table up until the next message is passed in which either contains no data subsets or
  ! else is a non-DX dictionary message.

  endtbl = .false.
  if(idxmsg(mbay(1,lun)).eq.1) then
    ! This is a DX dictionary message that was generated by the NCEPLIBS-bufr software.
    if(iupbs3(mbay(1,lun),'NSUB').eq.0) then
      ! But it doesn't contain any actual dictionary information, so assume we've reached the end of the dictionary table.
      if(idrdm(lun).gt.0) then
        endtbl = .true.
      endif
    else
      if(idrdm(lun).eq.0) then
        ! This is the first DX dictionary message that is part of a new dictionary table.
        call dxinit(lun,0)
      endif
      idrdm(lun) = idrdm(lun) + 1
      call stbfdx(lun,mbay(1,lun))
    endif
  else if(idrdm(lun).gt.0) then
    ! This is the first non-DX dictionary message received following a string of DX dictionary messages, so assume we've
    ! reached the end of the dictionary table.
    endtbl = .true.
  endif

  if(endtbl) then
    if ( iprt .ge. 2 ) then
      call errwrt('+++++++++++++++++++++++++++++++++++++++++++++++++')
      write ( unit=errstr, fmt='(A,I3,A)' ) &
        'BUFRLIB: READERME - STORED NEW DX TABLE CONSISTING OF (', idrdm(lun), ') MESSAGES;'
      call errwrt(errstr)
      errstr = 'WILL APPLY THIS TABLE TO ALL SUBSEQUENT DATA MESSAGES UNTIL NEXT DX TABLE IS PASSED IN'
      call errwrt(errstr)
      call errwrt('+++++++++++++++++++++++++++++++++++++++++++++++++')
      call errwrt(' ')
    endif
    idrdm(lun) = 0
    call makestab
  endif

  return
end subroutine readerme

!> Read the next BUFR message from logical unit lunit as an array of integer words.
!>
!> @param lunit - Fortran logical unit number for BUFR file.
!> @param mesg - BUFR message.
!> @param iret - return code:
!> - 0 normal return.
!> - -1 end-of-file encountered while reading from lunit.
!>
!> @author J. Ator @date 2005-11-29
subroutine rdmsgw(lunit,mesg,iret)

  use bufrlib

  use modv_vars, only: mxmsgld4

  implicit none

  integer, intent(in) :: lunit
  integer, intent(out) :: mesg(*), iret
  integer lun, il, im

  call status(lunit,lun,il,im)
  iret = -2
  do while (iret.le.-2)
     iret = crdbufr_c(lun,mesg,mxmsgld4)
     if(iret.eq.-3) call errwrt('BUFRLIB: RDMSGW - SKIPPING OVERLARGE MESSAGE')
     if(iret.eq.-2) call errwrt('BUFRLIB: RDMSGW - SKIPPING CORRUPTED MESSAGE')
  end do

  return
end subroutine rdmsgw

!> Open and initialize a new BUFR message within internal arrays, for eventual output to logical unit lunit.
!>
!> Logical unit lunit should have already been opened for output
!> operations via a previous call to subroutine openbf().
!>
!> This subroutine is similar to subroutine openmg(), except that it
!> will only open a new message if either subset or jdate has changed
!> since the previous call to this subroutine.  Otherwise, it will
!> leave the existing internal message unchanged so that the next data
!> subset can be written into the same internal message, thereby
!> improving overall storage efficiency by allowing the maximum number
!> of data subsets to be stored within each output BUFR message.  For
!> this reason, openmb() is much more widely used than openmg().
!>
!> If this subroutine does need to open and initialize a new BUFR
!> message for output (e.g. if the value of subset or jdate has changed
!> since the previous call to this subroutine), then any existing
!> message within the internal arrays will be automatically flushed and
!> written to logical unit lunit via an internal call to subroutine
!> closmg().  In this case, the behavior of this subroutine then
!> becomes exactly like that of subroutine openmg().
!>
!> @param lunit - Fortran logical unit number for BUFR file
!> @param subset - Table A mnemonic for type of BUFR BUFR message to be opened
!> (see [DX BUFR Tables](@ref dfbftab) for further information about Table A mnemonics)
!> @param jdate - Date-time to be stored within Section 1 of BUFR message being opened,
!> in format of either YYMMDDHH or YYYYMMDDHH
!>
!> @author J. Woollen @date 1994-01-06
recursive subroutine openmb(lunit,subset,jdate)

  use modv_vars, only: im8b

  use moda_msgcwd

  implicit none

  integer, intent(in) :: lunit, jdate
  integer my_lunit, my_jdate, lun, il, im, mtyp, mstb, inod, i4dy

  character*(*), intent(in) :: subset

  logical open

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunit,my_lunit,1)
    call x84(jdate,my_jdate,1)
    call openmb(my_lunit,subset,my_jdate)

    im8b=.true.
    return
  endif

  ! Check the file status

  call status(lunit,lun,il,im)
  if(il.eq.0) call bort('BUFRLIB: OPENMB - OUTPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR OUTPUT')
  if(il.lt.0) call bort('BUFRLIB: OPENMB - OUTPUT BUFR FILE IS OPEN FOR INPUT, IT MUST BE OPEN FOR OUTPUT')

  ! Get some subset particulars

  call nemtba(lun,subset,mtyp,mstb,inod)
  open = im.eq.0 .or. inod.ne.inode(lun) .or. i4dy(jdate).ne.idate(lun)

  ! Maybe(?) open a new or different type of message

  if(open) then
    call closmg(lunit)
    call wtstat(lunit,lun,il, 1)
    inode(lun) = inod
    idate(lun) = i4dy(jdate)
    ! Initialize the open message
    call msgini(lun)
    call usrtpl(lun,1,1)
  endif

  return
end subroutine openmb

!> Open and initialize a new BUFR message within internal arrays, for eventual output to logical unit lunit.
!>
!> Logical unit lunit should have already been opened for output
!> operations via a previous call to subroutine openbf().
!>
!> This subroutine is similar to subroutine openmb(), except that it
!> will always open a new message for output, regardless of the values
!> of subset and jdate. Any existing message within the internal
!> arrays will be automatically flushed and written to logical unit lunit
!> via an internal call to subroutine closmg().
!>
!> @param lunit - Fortran logical unit number for BUFR file
!> @param subset - Table A mnemonic for type of BUFR message to be opened
!> (see [DX BUFR Tables](@ref dfbftab) for further information about Table A mnemonics)
!> @param jdate - Date-time to be stored within Section 1 of BUFR message being opened,
!> in format of either YYMMDDHH or YYYYMMDDHH
!>
!> @author J. Woollen @date 1994-01-06
recursive subroutine openmg(lunit,subset,jdate)

  use modv_vars, only: im8b

  use moda_msgcwd

  implicit none

  integer, intent(in) :: lunit, jdate
  integer my_lunit, my_jdate, lun, il, im, mtyp, mstb, inod, i4dy

  character*(*), intent(in) :: subset

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunit,my_lunit,1)
    call x84(jdate,my_jdate,1)
    call openmg(my_lunit,subset,my_jdate)

    im8b=.true.
    return
  endif

  ! Check the file status

  call status(lunit,lun,il,im)
  if(il.eq.0) call bort('BUFRLIB: OPENMG - OUTPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR OUTPUT')
  if(il.lt.0) call bort('BUFRLIB: OPENMG - OUTPUT BUFR FILE IS OPEN FOR INPUT, IT MUST BE OPEN FOR OUTPUT')
  if(im.ne.0) call closmg(lunit)
  call wtstat(lunit,lun,il, 1)

  ! Get some subset particulars

  call nemtba(lun,subset,mtyp,mstb,inod)
  inode(lun) = inod
  idate(lun) = i4dy(jdate)

  ! Initialize the open message

  call msgini(lun)
  call usrtpl(lun,1,1)

  return
end subroutine openmg

!> Close the BUFR message that is currently open for
!> writing within internal arrays associated with logical unit
!> abs(lunin), then write the message to that logical unit.
!>
!> Logical unit abs(lunin) should have already been opened for output
!> operations via a previous call to subroutine openbf().
!>
!> If lunin < 0, then any message containing zero data subsets will
!> not be written to logical unit abs(lunin) for the remainder of the
!> life of the application program.  This includes suppressing the
!> writing of any "dummy" messages containing dump center and initiation
!> times that normally appear in the first 2 messages of NCEP dump files.
!>
!> @param lunin - Absolute value is Fortran logical unit number for BUFR file
!>
!> @author J. Woollen, D. Keyser @date 1994-01-06
recursive subroutine closmg(lunin)

  use modv_vars, only: im8b

  use moda_msgcwd
  use moda_msglim
  use moda_bitbuf

  implicit none

  integer, intent(in) :: lunin
  integer my_lunin, lunit, lun, il, im

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunin,my_lunin,1)
    call closmg(my_lunin)

    im8b=.true.
    return
  endif

  ! Check the file status

  lunit = abs(lunin)
  call status(lunit,lun,il,im)
  if(lunit.ne.lunin) msglim(lun) = 0
  if(il.eq.0) call bort('BUFRLIB: CLOSMG - OUTPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR OUTPUT')
  if(il.lt.0) call bort('BUFRLIB: CLOSMG - OUTPUT BUFR FILE IS OPEN FOR INPUT, IT MUST BE OPEN FOR OUTPUT')
  if(im.ne.0) THEN
    if(nsub(lun).gt.0) then
      call msgwrt(lunit,mbay(1,lun),mbyt(lun))
    else if(nsub(lun).eq.0.and.nmsg(lun).lt.msglim(lun)) then
      call msgwrt(lunit,mbay(1,lun),mbyt(lun))
    else if(nsub(lun).lt.0) then
      call wrcmps(-lunit)
    endif
  endif
  call wtstat(lunit,lun,il,0)

  return
end subroutine closmg

!> Perform final checks and updates on a BUFR message before writing it to a specified Fortran logical unit.
!>
!> These final checks and updates include:
!> - Standardizing the BUFR message, if requested via a previous call subroutine stdmsg()
!> - Converting the BUFR message from edition 3 to edition 4, if requested via a previous call to subroutine pkvs01()
!> - Storing any customized values into Section 0 or Section 1 of the BUFR message, if requested via one or more previous
!> calls to subroutine pkvs01()
!> - Storing a tank receipt time into Section 1 of the BUFR message, if requested via a previous call to subroutine strcpt()
!> - For edition 3 BUFR messages, ensuring each section of the message contains an even number of bytes
!> - Storing '7777' into the last four bytes of the BUFR message, and storing the final message length in Section 0
!> - Appending zeroed-out bytes after the end of the BUFR message, up to the next machine word boundary
!> - Encapsulating the BUFR message with IEEE Fortran control words, if requested via a previous call to subroutine setblock()
!> - Storing a copy of the final message into internal arrays for possible later retrival via subroutine writsa()
!>
!> @param lunit - Fortran logical unit number for BUFR file
!> @param mesg  - BUFR message
!> @param mgbyt - Size (in bytes) of BUFR message
!>
!> @author J. Woollen @date 1994-01-06
subroutine msgwrt(lunit,mesg,mgbyt)

  use bufrlib

  use modv_vars, only: mxmsgld4

  use moda_nulbfr
  use moda_bufrmg
  use moda_mgwa
  use moda_mgwb
  use moda_s01cm
  use moda_tnkrcp
  use moda_msgstd

  implicit none

  integer, intent(in) :: lunit, mgbyt, mesg(*)
  integer iprt, iec0(2), mbyt, ibit, kbit, ii, jj, len0, len1, len2, len3, len4, l5, iad4, iad5, lun, il, im, npbyt, mwrd, &
    nmwrd, iupbs01, idxmsg

  character*128 errstr
  character*4 bufr, sevn

  common /quiet/ iprt

  data bufr /'BUFR'/
  data sevn /'7777'/

  ! Make a local copy of the input message for use within this subroutine, since internal calls to any or all of the
  ! subroutines stndrd(), cnved4(), pkbs1(), atrcpt(), etc. may end up modifying the message before it finally gets
  ! written out to lunit.

  mbyt = mgbyt

  iec0(1) = mesg(1)
  iec0(2) = mesg(2)
  ibit = 32
  call pkb(mbyt,24,iec0,ibit)

  do ii = 1, nmwrd(iec0)
    mgwa(ii) = mesg(ii)
  enddo

  ! Overwrite any values within Section 0 or Section 1 that were requested via previous calls to pkvs01().  If a request
  ! was made to change the BUFR edition number to 4, then actually convert the message as well.

  if(ns01v.gt.0) then
    do jj=1,ns01v
      if(cmnem(jj).eq.'BEN') then
        if(ivmnem(jj).eq.4) then
          ! Install Section 0 byte count for use by cnved4()
          ibit = 32
          call pkb(mbyt,24,mgwa,ibit)
          call cnved4(mgwa,mxmsgld4,mgwb)
          ! Compute mbyt for the new edition 4 message
          mbyt = iupbs01(mgwb,'LENM')
          ! Copy the mgwb array back into mgwa
          do ii = 1, nmwrd(mgwb)
            mgwa(ii) = mgwb(ii)
          enddo
        endif
      else
        ! Overwrite the requested value
        call pkbs1(ivmnem(jj),mgwa,cmnem(jj))
      endif
    enddo
  endif

  ! Standardize the message if requested via module @ref moda_msgstd.  However, we don't want to do this if the message
  ! contains DX BUFR table information, because in that case it's already standard.

  if ( ( csmf.eq.'Y' ) .and. ( idxmsg(mgwa).ne.1 ) ) then
    ! Install Section 0 byte count and Section 5 '7777' into the original message.  This is necessary because
    ! subroutine stndrd() requires a complete and well-formed BUFR message as its input.
    ibit = 32
    call pkb(mbyt,24,mgwa,ibit)
    ibit = (mbyt-4)*8
    call pkc(sevn,4,mgwa,ibit)
    call stndrd(lunit,mgwa,mxmsgld4,mgwb)
    ! Compute mbyt for the new standardized message
    mbyt = iupbs01(mgwb,'LENM')
    ! Copy the mgwb array back into mgwa
    do ii = 1, nmwrd(mgwb)
      mgwa(ii) = mgwb(ii)
    enddo
  endif

  ! Append the tank receipt time to Section 1 if requested via module @ref moda_tnkrcp, unless the message contains
  ! DX BUFR table information.

  if ( ( ctrt.eq.'Y' ) .and. ( idxmsg(mgwa).ne.1 ) ) then
    ! Install Section 0 byte count for use by subroutine atrcpt()
    ibit = 32
    call pkb(mbyt,24,mgwa,ibit)
    call atrcpt(mgwa,mxmsgld4,mgwb)
    ! Compute mbyt for the revised message
    mbyt = iupbs01(mgwb,'LENM')
    ! Copy the mgwb array back into mgwa
    do ii = 1, nmwrd(mgwb)
      mgwa(ii) = mgwb(ii)
    enddo
  endif

  ! Get the section lengths.

  call getlens(mgwa,4,len0,len1,len2,len3,len4,l5)

  ! Depending on the edition number of the message, we need to ensure that each section within the message has an even
  ! number of bytes.

  if(iupbs01(mgwa,'BEN').lt.4) then
    if(mod(len1,2).ne.0) call bort ('BUFRLIB: MSGWRT - LENGTH OF SECTION 1 IS NOT A MULTIPLE OF 2')
    if(mod(len2,2).ne.0) call bort ('BUFRLIB: MSGWRT - LENGTH OF SECTION 2 IS NOT A MULTIPLE OF 2')
    if(mod(len3,2).ne.0) call bort ('BUFRLIB: MSGWRT - LENGTH OF SECTION 3 IS NOT A MULTIPLE OF 2')
    if(mod(len4,2).ne.0) then
      ! Pad Section 4 with an additional byte that is zeroed out
      iad4 = len0+len1+len2+len3
      iad5 = iad4+len4
      ibit = iad4*8
      len4 = len4+1
      call pkb(len4,24,mgwa,ibit)
      ibit = iad5*8
      call pkb(0,8,mgwa,ibit)
      mbyt = mbyt+1
    endif
  endif

  ! Write Section 0 byte count and Section 5

  ibit = 0
  call pkc(bufr, 4,mgwa,ibit)
  call pkb(mbyt,24,mgwa,ibit)

  kbit = (mbyt-4)*8
  call pkc(sevn, 4,mgwa,kbit)

  ! Zero out the extra bytes which will be written. Note that the BUFR message is stored within the integer array mgwa(*),
  ! (rather than within a character array), so we need to make sure that the "7777" Is followed by zeroed-out bytes up to
  ! the boundary of the last machine word that will be written out.

  call padmsg(mgwa,mxmsgld4,npbyt)

  ! Write the message plus padding to a word boundary if null(lun) = 0

  mwrd = nmwrd(mgwa)
  call status(lunit,lun,il,im)
  if(null(lun).eq.0) then
    call blocks(mgwa,mwrd)
    call cwrbufr_c(lun,mgwa,mwrd)
  endif

  if(iprt.ge.2) then
    call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
    write ( unit=errstr, fmt='(A,I4,A,I7)') 'BUFRLIB: MSGWRT: LUNIT =', lunit, ', BYTES =', mbyt+npbyt
    call errwrt(errstr)
    call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
    call errwrt(' ')
  endif

  ! Save a memory copy of this message, unless it's a DX message.

  if(idxmsg(mgwa).ne.1) then
    ! Store a copy of this message within module @ref moda_bufrmg, for possible later retrieval during a future call to
    ! subroutine writsa()
    msglen(lun) = mwrd
    do ii=1,msglen(lun)
      msgtxt(ii,lun) = mgwa(ii)
    enddo
  endif

  return
end subroutine msgwrt

!> Initialize, within the internal arrays, a new uncompressed BUFR message for output.
!>
!> Arrays are filled in common block msgptr and modules @ref moda_msgcwd and @ref moda_bitbuf.
!>
!> @param lun - file ID
!>
!> @author Woollen @date 1994-01-06
subroutine msgini(lun)

  use moda_msgcwd
  use moda_ufbcpl
  use moda_bitbuf
  use moda_tables

  implicit none

  integer, intent(in) :: lun
  integer ibct, ipd1, ipd2, ipd3, ipd4, nby0, nby1, nby2, nby3, nby4, nby5, nbyt, mtyp, msbt, inod, isub, iret, &
    mcen, mear, mmon, mday, mour, mmin, mbit

  character*128 bort_str
  character*8 subtag
  character*4 bufr, sevn
  character tab

  data bufr /'BUFR'/
  data sevn /'7777'/

  common /padesc/ ibct,ipd1,ipd2,ipd3,ipd4
  common /msgptr/ nby0,nby1,nby2,nby3,nby4,nby5

  ! Get the message tag and type, and break up the date

  subtag = tag(inode(lun))(1:8)
  call nemtba(lun,subtag,mtyp,msbt,inod)
  if(inode(lun).ne.inod) then
    write(bort_str,'("BUFRLIB: MSGINI - MISMATCH BETWEEN INODE (=",I7,") & POSITIONAL INDEX, INOD (",I7,") '// &
      'OF SUBTAG (",A,") IN DICTIONARY")') inode(lun), inod, subtag
    call bort(bort_str)
  endif
  call nemtab(lun,subtag,isub,tab,iret)
  if(iret.eq.0) then
    write(bort_str,'("BUFRLIB: MSGINI - TABLE A MESSAGE TYPE MNEMONIC ",A," NOT FOUND IN INTERNAL TABLE D ARRAYS")') subtag
    call bort(bort_str)
  endif

  ! Date can be YYMMDDHH or YYYYMMDDHH

  mcen = mod(idate(lun)/10**8,100)+1
  mear = mod(idate(lun)/10**6,100)
  mmon = mod(idate(lun)/10**4,100)
  mday = mod(idate(lun)/10**2,100)
  mour = mod(idate(lun)      ,100)
  mmin = 0

  if(mcen.eq.1) call bort ('BUFRLIB: MSGINI - BUFR MESSAGE DATE (IDATE) is 0000000000')

  if(mear.eq.0) mcen = mcen-1
  if(mear.eq.0) mear = 100

  ! Initialize the message

  mbit = 0
  nby0 = 8
  nby1 = 18
  nby2 = 0
  nby3 = 20
  nby4 = 4
  nby5 = 4
  nbyt = nby0+nby1+nby2+nby3+nby4+nby5

  ! Section 0

  call pkc(bufr ,  4 , mbay(1,lun),mbit)
  call pkb(nbyt , 24 , mbay(1,lun),mbit)
  call pkb(   3 ,  8 , mbay(1,lun),mbit)

  ! Section 1

  call pkb(nby1 , 24 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)
  call pkb(   3 ,  8 , mbay(1,lun),mbit)
  call pkb(   7 ,  8 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)
  call pkb(mtyp ,  8 , mbay(1,lun),mbit)
  call pkb(msbt ,  8 , mbay(1,lun),mbit)
  call pkb(  36 ,  8 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)
  call pkb(mear ,  8 , mbay(1,lun),mbit)
  call pkb(mmon ,  8 , mbay(1,lun),mbit)
  call pkb(mday ,  8 , mbay(1,lun),mbit)
  call pkb(mour ,  8 , mbay(1,lun),mbit)
  call pkb(mmin ,  8 , mbay(1,lun),mbit)
  call pkb(mcen ,  8 , mbay(1,lun),mbit)

  ! Section 3

  call pkb(nby3 , 24 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)
  call pkb(   0 , 16 , mbay(1,lun),mbit)
  call pkb(2**7 ,  8 , mbay(1,lun),mbit)
  call pkb(ibct , 16 , mbay(1,lun),mbit)
  call pkb(isub , 16 , mbay(1,lun),mbit)
  call pkb(ipd1 , 16 , mbay(1,lun),mbit)
  call pkb(ipd2 , 16 , mbay(1,lun),mbit)
  call pkb(ipd3 , 16 , mbay(1,lun),mbit)
  call pkb(ipd4 , 16 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)

  ! Section 4

  call pkb(nby4 , 24 , mbay(1,lun),mbit)
  call pkb(   0 ,  8 , mbay(1,lun),mbit)

  ! Section 5

  call pkc(sevn ,  4 , mbay(1,lun),mbit)

  ! Double check initial message length

  if(mod(mbit,8).ne.0) call bort('BUFRLIB: MSGINI - INITIALIZED MESSAGE DOES NOT END ON A BYTE BOUNDARY')
  if(mbit/8.ne.nbyt) then
    write(bort_str,'("BUFRLIB: MSGINI - NUMBER OF BYTES STORED FOR INITIALIZED MESSAGE (",I6,") IS NOT THE SAME AS FIRST '// &
      'CALCULATED, NBYT (",I6)') mbit/8, nbyt
    call bort(bort_str)
  endif

  nmsg(lun) = nmsg(lun)+1
  nsub(lun) = 0
  mbyt(lun) = nbyt

  luncpy(lun)=0

  return
end subroutine msgini

!> Check whether the current data subset in the internal arrays will fit within the current BUFR message in the
!> internal arrays, based on the prescribed maximum size of a BUFR message and the allowance of some extra "wiggle room"
!> that may be needed later when writing out the message.
!>
!> @param msiz - Size (in bytes) of current BUFR message
!> @param itoadd - Size (in bytes) of current data subset
!> @param mxsiz - Maximum size of a BUFR message
!> @returns msgfull - Flag indicating whether the current data subset will fit within the current BUFR message
!>
!> @author J. Ator @date 2009-03-23
logical function msgfull(msiz,itoadd,mxsiz) result(bool)

  use modv_vars, only: maxnc

  use moda_tnkrcp
  use moda_msgstd

  implicit none

  integer, intent(in) :: msiz, itoadd, mxsiz
  integer iwgbyt

  ! Allow for at least 11 additional bytes of "wiggle room" in the message, because subroutine msgwrt() may do any or all
  ! of the following:
  !      3 bytes may be added by a call to subroutine cnved4()
  !    + 1 byte (at most) of padding may be added to Section 4
  !    + 7 bytes (at most) of padding may be added up to the next word boundary after Section 5
  !   ----
  !     11
  iwgbyt = 11

  ! But subroutine msgwrt() may also do any of all of the following:

  ! 6 bytes may be added by a call to subroutine atrcpt()
  if(ctrt.eq.'Y') iwgbyt = iwgbyt + 6

  ! (maxnc*2) bytes (at most) may be added by a call to subroutine stndrd()
  if(csmf.eq.'Y') iwgbyt = iwgbyt + (maxnc*2)

  ! Determine whether the subset will fit.

  if ( ( msiz + itoadd + iwgbyt ) .gt. mxsiz ) then
    bool = .true.
  else
    bool = .false.
  endif

  return
end function msgfull

!> Specify the maximum length of a BUFR message that can be written
!> to any output file by the NCEPLIBS-bufr software.
!>
!> This subroutine can be called from within an application program at
!> any time after the initial call to subroutine openbf(), and the
!> specified value maxo will then be used for all future BUFR messages
!> written by the software to all output files for the remainder of
!> the program, unless another call is made to this same subroutine
!> to reset the value of maxo again.  Otherwise, if this subroutine
!> is never called, a default maximum message length is used for all
!> output files, as set via an initial internal call to subroutine
!> bfrini().
!>
!> @param maxo - New maximum length (in bytes) for all BUFR messages written to all output files
!>   - 0 = Set maxo to the maximum value allowed by the NCEPLIBS-bufr software
!>
!> @authors J. Woollen, J. Ator @date 2002-05-14
recursive subroutine maxout(maxo)

  use modv_vars, only: mxmsgl, im8b

  use moda_bitbuf

  implicit none

  integer, intent(in) :: maxo
  integer my_maxo, iprt, newsiz, maxdx, idxv, nxstr, ldxa, ldxb, ldxd, ld30

  character*128 errstr
  character*56 dxstr

  common /dxtab/ maxdx,idxv,nxstr(10),ldxa(10),ldxb(10),ldxd(10),ld30(10),dxstr(10)
  common /quiet/ iprt

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(maxo,my_maxo,1)
    call maxout(my_maxo)

    im8b=.true.
    return
  endif

  if((maxo.eq.0).or.(maxo.gt.mxmsgl)) then
    newsiz = mxmsgl
  else
    newsiz = maxo
  endif

  if(iprt.ge.0) then
    if(maxbyt.ne.newsiz) then
      call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
      write ( unit=errstr, fmt='(A,A,I7,A,I7)' ) 'BUFRLIB: MAXOUT - THE RECORD LENGTH OF ALL BUFR MESSAGES ',&
        'CREATED FROM THIS POINT ON IS BEING CHANGED FROM ', maxbyt, ' TO ', newsiz
      call errwrt(errstr)
      call errwrt('++++++++++++++BUFR ARCHIVE LIBRARY+++++++++++++++++')
      call errwrt(' ')
    endif
  endif

  maxbyt = newsiz
  maxdx  = newsiz

  return
end subroutine maxout

!> Get the maximum length of a BUFR message that can be written to an output file by the NCEPLIBS-bufr software.
!>
!> @returns igetmxby - Maximum length of a BUFR message that can be written to an output file by the NCEPLIBS-bufr software
!>
!> This maximum length value can be changed at any time via a
!> separate call to subroutine maxout().
!>
!> @author J. Ator @date 2016-06-27
integer function igetmxby() result(iret)

  use moda_bitbuf

  implicit none

  iret = maxbyt

  return
end function igetmxby

!> Pad a BUFR message with zeroed-out bytes from the end of the message up to the next 8-byte boundary.
!>
!> @param mesg - BUFR message:
!>  - on input, contains BUFR message to be padded
!>  - on output, contains BUFR message with npbyt zeroed-out bytes appended to the end
!> @param lmesg - Dimensioned size (in integer words) of mesg;
!> used by the subroutine to ensure that it does not overflow the mesg array
!> @param npbyt - Number of zeroed-out bytes appended to mesg
!>
!> @author Ator @date 2005-11-29
subroutine padmsg(mesg,lmesg,npbyt)

  use modv_vars, only: nbytw

  implicit none

  integer, intent(in) :: lmesg
  integer, intent(inout) :: mesg(*)
  integer, intent(out) :: npbyt
  integer nmw, nmb, ibit, i, nmwrd, iupbs01

  ! Make sure that the array is big enough to hold the additional byte padding that will be appended to the
  ! end of the message.

  nmw = nmwrd(mesg)
  if(nmw.gt.lmesg) call bort('BUFRLIB: PADMSG - CANNOT ADD PADDING TO MESSAGE ARRAY; TRY A LARGER DIMENSION FOR THIS ARRAY')

  ! Pad from the end of the message up to the next 8-byte boundary.

  nmb = iupbs01(mesg,'LENM')
  ibit = nmb*8
  npbyt = ( nmw * nbytw ) - nmb
  do i = 1, npbyt
    call pkb(0,8,mesg,ibit)
  enddo

  return
end subroutine padmsg

!> Get the total number of data subsets available within the BUFR message that was most recently opened for reading
!> via a call to one of the [message-reading subroutines](@ref hierarchy) for a specified Fortran logical unit.
!>
!> The data subsets themselves do not need to have already been read via previous calls to any of the
!> [subset-reading subroutines](@ref hierarchy).
!>
!> @param lunit - Fortran logical unit number for BUFR file
!> @returns nmsub - Number of data subsets
!>
!> @author J. Woollen @date 1994-01-06
recursive integer function nmsub(lunit) result(iret)

  use modv_vars, only: im8b

  use moda_msgcwd

  implicit none

  integer, intent(in) :: lunit
  integer my_lunit, lun, il, im

  ! Check for I8 integers

  if(im8b) then
    im8b=.false.

    call x84(lunit,my_lunit,1)
    iret=nmsub(my_lunit)

    im8b=.true.
    return
  endif

  iret = 0

  ! Check the file status

  call status(lunit,lun,il,im)
  if(il.eq.0) call bort('BUFRLIB: NMSUB - INPUT BUFR FILE IS CLOSED, IT MUST BE OPEN FOR INPUT')
  if(il.gt.0) call bort('BUFRLIB: NMSUB - INPUT BUFR FILE IS OPEN FOR OUTPUT, IT MUST BE OPEN FOR INPUT')
  if(im.eq.0) call bort('BUFRLIB: NMSUB - A MESSAGE MUST BE OPEN IN INPUT BUFR FILE, NONE ARE')

  iret = msub(lun)

  return
end function nmsub

!> Given an integer array containing Section 0 from a BUFR message, determine the array size (in integers)
!> needed to store the entire BUFR message.
!>
!> This function is similar to function lmsg(), except that it takes an integer array as input rather than a character string.
!>
!> @param mbay - Section 0 from a BUFR message
!> @returns nmwrd - Array size (in integers) needed to store entire BUFR message
!>
!> @remarks
!> - In some cases, the value returned may be slightly larger than the minimum number of integers needed to store the
!> entire BUFR message.
!>
!> @author J. Ator @date 2005-11-29
integer function nmwrd(mbay) result(iret)

  use modv_vars, only: nbytw

  implicit none

  integer, intent(in) :: mbay(*)
  integer lenm, iupbs01

  lenm = iupbs01(mbay,'LENM')
  if(lenm.eq.0) then
    iret = 0
  else
    iret = ((lenm/8)+1)*(8/nbytw)
  endif

  return
end function nmwrd

!> Given a character string containing Section 0 from a BUFR message, determine the array size (in integers)
!> needed to store the entire BUFR message.
!>
!> This function is similar to function nmwrd(), except that it takes a character string as input rather than an integer array.
!>
!> @param sec0 - Section 0 from a BUFR message
!> @returns lmsg - Array size (in integers) needed to store entire BUFR message
!>
!> @remarks
!> - In some cases, the value returned may be slightly larger than the minimum number of integers needed to store the
!> entire BUFR message.
!>
!> @author J. Woollen @date 1994-01-06
integer function lmsg(sec0) result(iret)

  implicit none

  integer msec0(2), nmwrd

  character*8, intent(in) :: sec0
  character*8 csec0

  equivalence(msec0,csec0)

  csec0 = sec0
  iret = nmwrd(msec0)

  return
end function lmsg

!> Read the section lengths of a BUFR message, up to a specified point in the message.
!>
!> This subroutine will work on any BUFR message encoded using BUFR edition 2, 3, or 4.
!>
!> @param mbay - BUFR message
!> @param ll - Number of last section for which the length is to be read. In other words, setting ll = N means to
!> read and return the lengths of Sections 0 through N (i.e. len0, len1,...,lenN).  Any section lengths that are not
!> specified to be read are returned with a default placeholder value of -1.
!> @param len0 - Length (in bytes) of Section 0
!> @param len1 - Length (in bytes) of Section 1
!> @param len2 - Length (in bytes) of Section 2
!> @param len3 - Length (in bytes) of Section 3
!> @param len4 - Length (in bytes) of Section 4
!> @param len5 - Length (in bytes) of Section 5
!>
!> @remarks
!> - The start of the BUFR message (i.e. the string 'BUFR') must be aligned on the first 4 bytes of mbay.
!>
!> @author J. Ator @date 2005-11-29
recursive subroutine getlens (mbay,ll,len0,len1,len2,len3,len4,len5)

  use modv_vars, only: im8b

  implicit none

  integer, intent(in) :: mbay(*), ll
  integer, intent(out) :: len0, len1, len2, len3, len4, len5
  integer my_ll, iad2, iad3, iad4, iupbs01, iupb

  ! Check for I8 integers.
  if(im8b) then
    im8b=.false.
    call x84(ll,my_ll,1)
    call getlens(mbay,my_ll,len0,len1,len2,len3,len4,len5)
    call x48(len0,len0,1)
    call x48(len1,len1,1)
    call x48(len2,len2,1)
    call x48(len3,len3,1)
    call x48(len4,len4,1)
    call x48(len5,len5,1)
    im8b=.true.
    return
  endif

  len0 = -1
  len1 = -1
  len2 = -1
  len3 = -1
  len4 = -1
  len5 = -1

  if(ll.lt.0) return
  len0 = iupbs01(mbay,'LEN0')

  if(ll.lt.1) return
  len1 = iupbs01(mbay,'LEN1')

  if(ll.lt.2) return
  iad2 = len0 + len1
  len2 = iupb(mbay,iad2+1,24) * iupbs01(mbay,'ISC2')

  if(ll.lt.3) return
  iad3 = iad2 + len2
  len3 = iupb(mbay,iad3+1,24)

  if(ll.lt.4) return
  iad4 = iad3 + len3
  len4 = iupb(mbay,iad4+1,24)

  if(ll.lt.5) return
  len5 = 4

  return
end subroutine getlens

!> Convert a BUFR edition 3 message to BUFR edition 4.
!>
!> This subroutine reads an input BUFR message encoded using BUFR
!> edition 3, then outputs an equivalent BUFR message encoded using
!> BUFR edition 4.
!>
!> This subroutine performs the same function as subroutine pkvs01()
!> when the latter is called with s01mnem = 'BEN' and ival = 4, except
!> that the latter subroutine operates on BUFR messages internally
!> within the software, whereas this subroutine operates on a single
!> BUFR message passed in via a memory array.
!>
!> @param msgin - BUFR message
!> @param lmsgot - Dimensioned size (in integers) of msgot; used by the subroutine to ensure that it doesn't overflow
!> the msgot array
!> @param msgot - Copy of msgin encoded using BUFR edition 4
!>
!> @remarks
!> - msgin and msgot must be separate arrays.
!> - BUFR edition 4 messages are usually longer in length than their
!> BUFR edition 3 counterparts, so it's usually a good idea to allow
!> for extra space when allocating msgot within the application program.
!>
!> @author J. Ator @date 2005-11-29
recursive subroutine cnved4(msgin,lmsgot,msgot)

  use modv_vars, only: im8b, nbytw

  implicit none

  integer, intent(in) :: msgin(*), lmsgot
  integer, intent(out) :: msgot(*)
  integer my_lmsgot, i, nmw, len0, len1, len2, len3, l4, l5, iad2, iad4, lenm, lenmot, len1ot, len3ot, ibit, iupbs01, nmwrd

  ! Check for I8 integers.

  if(im8b) then
    im8b=.false.
    call x84 ( lmsgot, my_lmsgot, 1 )
    call cnved4 ( msgin, my_lmsgot*2, msgot )
    im8b=.true.
    return
  endif

  if(iupbs01(msgin,'BEN').eq.4) then

    ! The input message is already encoded using edition 4, so just copy it from msgin to msgot and then return.

    nmw = nmwrd(msgin)
    if(nmw.gt.lmsgot) &
      call bort('BUFRLIB: CNVED4 - OVERFLOW OF OUTPUT (EDITION 4) MESSAGE ARRAY; TRY A LARGER DIMENSION FOR THIS ARRAY')
    do i = 1, nmw
      msgot(i) = msgin(i)
    enddo
    return
  endif

  ! Get some section lengths and addresses from the input message.

  call getlens(msgin,3,len0,len1,len2,len3,l4,l5)

  iad2 = len0 + len1
  iad4 = iad2 + len2 + len3

  lenm = iupbs01(msgin,'LENM')

  ! Check for overflow of the output array.  Note that the new edition 4 message will be a total of 3 bytes longer than the
  ! input message (i.e. 4 more bytes in Section 1, but 1 fewer byte in Section 3).

  lenmot = lenm + 3
  if(lenmot.gt.(lmsgot*nbytw)) &
    call bort('BUFRLIB: CNVED4 - OVERFLOW OF OUTPUT (EDITION 4) MESSAGE ARRAY; TRY A LARGER DIMENSION FOR THIS ARRAY')

  len1ot = len1 + 4
  len3ot = len3 - 1

  ! Write Section 0 of the new message into the output array.

  call mvb ( msgin, 1, msgot, 1, 4 )
  ibit = 32
  call pkb ( lenmot, 24, msgot, ibit )
  call pkb ( 4, 8, msgot, ibit )

  ! Write Section 1 of the new message into the output array.

  call pkb ( len1ot, 24, msgot, ibit )
  call pkb ( iupbs01(msgin,'BMT'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'OGCE'), 16, msgot, ibit )
  call pkb ( iupbs01(msgin,'GSES'), 16, msgot, ibit )
  call pkb ( iupbs01(msgin,'USN'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'ISC2')*128, 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'MTYP'), 8, msgot, ibit )
  ! Set a default of 255 for the international subcategory.
  call pkb ( 255, 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'MSBT'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'MTV'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'MTVL'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'YEAR'), 16, msgot, ibit )
  call pkb ( iupbs01(msgin,'MNTH'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'DAYS'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'HOUR'), 8, msgot, ibit )
  call pkb ( iupbs01(msgin,'MINU'), 8, msgot, ibit )
  ! Set a default of 0 for the second.
  call pkb ( 0, 8, msgot, ibit )

  ! Copy Section 2 (if it exists) through the next-to-last byte of Section 3 from the input array to the output array.

  call mvb ( msgin, iad2+1, msgot, (ibit/8)+1, len2+len3-1 )

  ! Store the length of the new Section 3.

  ibit = ( len0 + len1ot + len2 ) * 8
  call pkb ( len3ot, 24, msgot, ibit )

  ! Copy Section 4 and Section 5 from the input array to the output array.

  ibit = ibit + ( len3ot * 8 ) - 24
  call mvb ( msgin, iad4+1, msgot, (ibit/8)+1, lenm-iad4 )

  return
end subroutine cnved4
